<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Bulk Renamer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .privacy-notice {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .settings {
            background: #f5f5f5;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .settings h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .info-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .preview {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
            margin-top: 15px;
        }

        .preview strong {
            color: #667eea;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 30px 0;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }

        .upload-area.drag-over {
            background: #e8eaff;
            border-color: #764ba2;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        input[type="file"] {
            display: none;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
            display: block;
            margin: 20px auto;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .file-list {
            margin: 20px 0;
        }

        .file-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item.processing {
            background: #fff3cd;
        }

        .file-item.success {
            background: #d4edda;
        }

        .file-item.error {
            background: #f8d7da;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .status-message {
            text-align: center;
            color: #666;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìÑ PDF Bulk Renamer</h1>
            <p class="subtitle">Extract text from upper left corner & rename files automatically</p>
        </header>

        <div class="privacy-notice">
            üîí <strong>Secure & Private:</strong> All processing happens in your browser. Files never leave your computer.
        </div>

        <div class="settings">
            <h2>‚öôÔ∏è Settings</h2>
            
            <div class="info-box">
                üí° <strong>Hungarian Patent Office Documents:</strong> This tool extracts the case number (√úgyiratsz√°m) and adds it to the filename with spaces around it for easy double-click selection. Original filename remains unchanged. Example: "NCBB062B_D9X_0_ E22753062 .pdf"
            </div>

            <div class="setting-group">
                <label for="searchText">Search for Text Label</label>
                <input type="text" id="searchText" value="√úgyiratsz√°m:" placeholder="Enter text to search for">
            </div>

            <div class="setting-group">
                <label>Extraction Pattern</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="patternCapital" name="pattern" value="capital" checked>
                        <label for="patternCapital">Capital letter followed by numbers (stops at / or space)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="patternAll" name="pattern" value="all">
                        <label for="patternAll">All text after label</label>
                    </div>
                </div>
                <small style="color: #666; display: block; margin-top: 8px;">
                    <strong>Current:</strong> Capital letter followed by numbers (stops at / or space)
                </small>
            </div>

            <div class="setting-group">
                <label>Separator Character</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="sepSpace" name="separator" value=" " checked>
                        <label for="sepSpace">Space (allows double-click selection)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="sepUnderscore" name="separator" value="_">
                        <label for="sepUnderscore">Underscore (_)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="sepDash" name="separator" value="-">
                        <label for="sepDash">Dash (-)</label>
                    </div>
                </div>
            </div>

            <div class="setting-group">
                <label>Keep Original Extension</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="extYes" name="extension" value="yes" checked>
                        <label for="extYes">Yes (.pdf)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="extNo" name="extension" value="no">
                        <label for="extNo">No</label>
                    </div>
                </div>
            </div>

            <div class="preview">
                <strong>Preview:</strong> <span id="previewText">NCBB062B_D9X_0_ E22753062 .pdf</span><br>
                <small style="color: #666;">Original name (unchanged) + space + extracted case number + space + extension</small>
            </div>

            <div class="setting-group">
                <label>
                    <input type="checkbox" id="debugMode" style="width: auto; display: inline;">
                    Show extracted text (debug mode)
                </label>
            </div>
        </div>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÑ</div>
            <h3>Click to upload or drag & drop PDF files</h3>
            <p style="color: #666; margin-top: 10px;">Support for multiple files</p>
            <input type="file" id="fileInput" accept=".pdf" multiple>
        </div>

        <div class="file-list" id="fileList"></div>

        <div id="debugOutput" style="display: none; background: #f0f0f0; padding: 15px; margin: 20px 0; border-radius: 8px; max-height: 300px; overflow-y: auto;">
            <h3>Debug Output:</h3>
            <textarea id="debugText" style="width: 100%; height: 200px; font-family: monospace; font-size: 12px; padding: 10px;" readonly></textarea>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="status-message" id="statusMessage"></div>
        </div>

        <button id="processBtn" disabled>Process PDFs</button>
        <button id="downloadBtn" style="display: none;">Download ZIP</button>

        <footer>
            <p>Made with ‚ù§Ô∏è for efficient document management</p>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let selectedFiles = [];
        let processedFiles = [];
        let debugLog = [];

        function addDebugLog(message) {
            debugLog.push(message);
            const debugText = document.getElementById('debugText');
            if (debugText) {
                debugText.value = debugLog.join('\n');
                debugText.scrollTop = debugText.scrollHeight;
            }
        }

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const statusMessage = document.getElementById('statusMessage');

        // Upload area interactions
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        function handleFiles(files) {
            selectedFiles = files;
            displayFileList();
            processBtn.disabled = files.length === 0;
            downloadBtn.style.display = 'none';
            processedFiles = [];
        }

        function displayFileList() {
            fileList.innerHTML = '';
            selectedFiles.forEach(file => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `<span>üìÑ ${file.name}</span><span>${(file.size / 1024).toFixed(2)} KB</span>`;
                fileList.appendChild(div);
            });
        }

        async function extractTextFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const page = await pdf.getPage(1);
                
                // First try to extract text normally
                const textContent = await page.getTextContent();
                
                if (textContent.items.length > 0) {
                    // PDF has text layer - use normal extraction
                    const viewport = page.getViewport({ scale: 1.0 });
                    const pageHeight = viewport.height;
                    const upperLeftItems = textContent.items.filter(item => {
                        return item.transform[5] > pageHeight * 0.7;
                    });
                    
                    return upperLeftItems.map(item => item.str).join(' ');
                } else {
                    // PDF is scanned - use OCR
                    statusMessage.textContent = `Running OCR on ${file.name}...`;
                    
                    const scale = 2.0;
                    const viewport = page.getViewport({ scale });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    // Crop to upper left corner (top 30% of page)
                    const cropHeight = Math.floor(canvas.height * 0.3);
                    const croppedCanvas = document.createElement('canvas');
                    croppedCanvas.width = canvas.width;
                    croppedCanvas.height = cropHeight;
                    const croppedContext = croppedCanvas.getContext('2d');
                    croppedContext.drawImage(canvas, 0, 0);

                    // Run OCR with better configuration
                    const result = await Tesseract.recognize(
                        croppedCanvas,
                        'hun+eng',
                        {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    statusMessage.textContent = `OCR: ${file.name} - ${Math.round(m.progress * 100)}%`;
                                }
                            },
                            // Better OCR settings
                            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                            preserve_interword_spaces: '1',
                        }
                    );

                    // Get text and ensure proper encoding
                    let extractedText = result.data.text;
                    
                    // Check if we got weird encoding (UTF-16 as UTF-8)
                    if (extractedText.includes('ÊòÄ') || extractedText.includes('ÂúÄ') || extractedText.includes('ÂåÄ')) {
                        // Text was incorrectly encoded - try to fix it or re-process
                        statusMessage.textContent = `Retrying OCR with different settings...`;
                        
                        // Try with a higher quality render
                        const scale2 = 3.0;
                        const viewport2 = page.getViewport({ scale: scale2 });
                        const canvas2 = document.createElement('canvas');
                        const context2 = canvas2.getContext('2d');
                        canvas2.height = viewport2.height;
                        canvas2.width = viewport2.width;

                        await page.render({
                            canvasContext: context2,
                            viewport: viewport2
                        }).promise;

                        const cropHeight2 = Math.floor(canvas2.height * 0.3);
                        const croppedCanvas2 = document.createElement('canvas');
                        croppedCanvas2.width = canvas2.width;
                        croppedCanvas2.height = cropHeight2;
                        const croppedContext2 = croppedCanvas2.getContext('2d');
                        croppedContext2.drawImage(canvas2, 0, 0);

                        // Enhance contrast
                        const imageData = croppedContext2.getImageData(0, 0, croppedCanvas2.width, croppedCanvas2.height);
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            // Convert to grayscale and increase contrast
                            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const contrasted = avg > 128 ? 255 : 0;
                            data[i] = data[i + 1] = data[i + 2] = contrasted;
                        }
                        croppedContext2.putImageData(imageData, 0, 0);

                        const result2 = await Tesseract.recognize(
                            croppedCanvas2,
                            'hun',
                            {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        statusMessage.textContent = `OCR (retry): ${file.name} - ${Math.round(m.progress * 100)}%`;
                                    }
                                }
                            }
                        );

                        extractedText = result2.data.text;
                    }

                    return extractedText;
                }
            } catch (error) {
                console.error('Error extracting text:', error);
                throw error;
            }
        }

        function extractCaseNumber(text) {
            const debugMode = document.getElementById('debugMode').checked;
            const searchText = document.getElementById('searchText').value;
            const pattern = document.querySelector('input[name="pattern"]:checked').value;

            if (debugMode) {
                addDebugLog('=== Starting extraction ===');
                addDebugLog('Search text: ' + searchText);
            }

            // Normalize text for better matching (handle OCR errors with Hungarian characters)
            let normalizedText = text;
            
            // Try multiple variations of the search text for OCR errors
            const searchVariations = [
                searchText,
                searchText.replace('√º', '√º').replace('√°', '√°'), // already normalized
                '√úgyiratsz√°m:',
                'Ugyiratszam:',
                '√úg≈Çiƒæatszam:', // OCR common error
                '√úgyiratszam',
                'Ugyiratsz√°m'
            ];

            let searchIndex = -1;
            let foundVariation = null;
            
            for (const variation of searchVariations) {
                searchIndex = normalizedText.indexOf(variation);
                if (searchIndex !== -1) {
                    foundVariation = variation;
                    break;
                }
            }

            if (searchIndex === -1) {
                // Try case-insensitive search as last resort
                const lowerText = normalizedText.toLowerCase();
                const lowerSearch = searchText.toLowerCase();
                searchIndex = lowerText.indexOf(lowerSearch);
                if (searchIndex !== -1) {
                    foundVariation = searchText;
                    if (debugMode) addDebugLog('Found via case-insensitive search');
                } else {
                    if (debugMode) {
                        addDebugLog('Search text NOT found!');
                        addDebugLog('First 500 chars of extracted text:');
                        addDebugLog(normalizedText.substring(0, 500));
                    }
                    return null;
                }
            } else {
                if (debugMode) addDebugLog('Found search variation: ' + foundVariation);
            }

            const afterLabel = normalizedText.substring(searchIndex + (foundVariation ? foundVariation.length : searchText.length));
            if (debugMode) {
                addDebugLog('Text after label (first 200 chars):');
                addDebugLog(afterLabel.substring(0, 200));
            }
            
            // Split by newlines and get the next non-empty line
            const lines = afterLabel.split(/[\n\r]+/);
            let caseNumberLine = '';
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.length > 0) {
                    caseNumberLine = trimmed;
                    break;
                }
            }

            if (!caseNumberLine) return null;

            if (debugMode) addDebugLog('Case number line found: ' + caseNumberLine);

            if (pattern === 'capital') {
                // Clean up common OCR errors - more aggressive cleaning
                let cleaned = caseNumberLine
                    .replace(/[≈Çƒ∫ƒæ]/gi, '') // Remove OCR artifacts (case insensitive)
                    .replace(/[√†√°√¢√£√§√•ƒÅƒÉƒÖ«ª]/gi, 'a') // Normalize accented a
                    .replace(/[√®√©√™√´ƒìƒïƒóƒôƒõ]/gi, 'e') // Normalize accented e
                    .replace(/[√¨√≠√Æ√Øƒ©ƒ´ƒ≠ƒØƒ±]/gi, 'i') // Normalize accented i
                    .replace(/[√≤√≥√¥√µ√∂≈ç≈è≈ë«ø]/gi, 'o') // Normalize accented o
                    .replace(/[√π√∫√ª√º≈©≈´≈≠≈Ø≈±≈≥]/gi, 'u') // Normalize accented u
                    .replace(/[^A-Z0-9\/]/gi, '') // Remove everything except letters, numbers, and /
                    .toUpperCase(); // Ensure uppercase
                
                // Now replace O with 0 after other cleaning
                cleaned = cleaned.replace(/O/g, '0');
                
                if (debugMode) addDebugLog('Cleaned: ' + cleaned);
                
                // Match pattern: Capital letter(s) followed by numbers, optionally with / and more numbers
                const match = cleaned.match(/([A-Z]+\d+(?:\/\d+)?)/);
                if (match) {
                    if (debugMode) addDebugLog('‚úì MATCHED case number: ' + match[1]);
                    return match[1];
                }
                
                if (debugMode) addDebugLog('‚úó No match found');
                return null;
            } else {
                return caseNumberLine.trim();
            }
        }

        function generateNewFilename(originalName, caseNumber) {
            const separator = document.querySelector('input[name="separator"]:checked').value;
            const keepExtension = document.querySelector('input[name="extension"]:checked').value === 'yes';
            
            const baseName = originalName.replace('.pdf', '');
            const extension = keepExtension ? '.pdf' : '';
            
            return `${baseName}${separator}${caseNumber}${separator}${extension}`;
        }

        processBtn.addEventListener('click', async () => {
            processBtn.disabled = true;
            progressContainer.style.display = 'block';
            processedFiles = [];
            debugLog = [];
            
            const debugMode = document.getElementById('debugMode').checked;
            const debugOutput = document.getElementById('debugOutput');
            if (debugMode) {
                debugOutput.style.display = 'block';
            } else {
                debugOutput.style.display = 'none';
            }

            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                const fileItems = fileList.querySelectorAll('.file-item');
                fileItems[i].classList.add('processing');

                try {
                    statusMessage.textContent = `Processing ${file.name}...`;
                    const text = await extractTextFromPDF(file);
                    
                    // Debug mode - show extracted text in text area
                    if (document.getElementById('debugMode').checked) {
                        addDebugLog('\n========================================');
                        addDebugLog('FILE: ' + file.name);
                        addDebugLog('========================================');
                    }
                    
                    const caseNumber = extractCaseNumber(text);

                    if (caseNumber) {
                        const newFilename = generateNewFilename(file.name, caseNumber);
                        processedFiles.push({ file, newFilename });
                        fileItems[i].classList.remove('processing');
                        fileItems[i].classList.add('success');
                        fileItems[i].innerHTML = `<span>‚úì ${file.name}</span><span>‚Üí ${newFilename}</span>`;
                    } else {
                        fileItems[i].classList.remove('processing');
                        fileItems[i].classList.add('error');
                        fileItems[i].innerHTML = `<span>‚úó ${file.name}</span><span>Case number not found</span>`;
                    }
                } catch (error) {
                    fileItems[i].classList.remove('processing');
                    fileItems[i].classList.add('error');
                    fileItems[i].innerHTML = `<span>‚úó ${file.name}</span><span>Error: ${error.message}</span>`;
                }

                const progress = ((i + 1) / selectedFiles.length) * 100;
                progressFill.style.width = progress + '%';
                progressFill.textContent = Math.round(progress) + '%';
            }

            statusMessage.textContent = `Processed ${processedFiles.length} of ${selectedFiles.length} files`;
            
            if (processedFiles.length > 0) {
                downloadBtn.style.display = 'block';
            }
            
            processBtn.disabled = false;
        });

        downloadBtn.addEventListener('click', async () => {
            const zip = new JSZip();

            processedFiles.forEach(({ file, newFilename }) => {
                zip.file(newFilename, file);
            });

            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'renamed_pdfs.zip';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Update preview when settings change
        document.querySelectorAll('input[name="separator"], input[name="extension"]').forEach(input => {
            input.addEventListener('change', updatePreview);
        });

        function updatePreview() {
            const separator = document.querySelector('input[name="separator"]:checked').value;
            const keepExtension = document.querySelector('input[name="extension"]:checked').value === 'yes';
            const extension = keepExtension ? '.pdf' : '';
            const sepDisplay = separator === ' ' ? 'space' : separator;
            document.getElementById('previewText').textContent = 
                `NCBB062B_D9X_0_${separator}E22753062${separator}${extension}`;
        }
    </script>
</body>
</html>
